from flask import Flask, request, jsonify
from cryptography.fernet import Fernet
import sqlite3
import random
import string
from datetime import datetime

app = Flask(__name__)
key = Fernet.generate_key() # I know this is not secure, but it's only for testing purposes.


def encrypt(message, encryption_key):
    cipher_suite = Fernet(encryption_key)
    encrypted_message = cipher_suite.encrypt(message.encode())
    return encrypted_message


def decrypt(encrypted_message, encryption_key):
    cipher_suite = Fernet(encryption_key)
    decrypted_message = cipher_suite.decrypt(encrypted_message).decode()
    return decrypted_message


def genhwid():
    hex_digits = string.hexdigits[:16]
    sections = [8, 4, 4, 4, 12]

    hardware_id = ''
    for section in sections:
        hardware_id += ''.join(random.choices(hex_digits, k=section))
        if section != sections[-1]:
            hardware_id += '-'

    return hardware_id


def geninfo():
    hardware_id = encrypt(genhwid(), key).decode('utf-8')
    exe_path = encrypt("C:\\Windows\\explorer.exe", key).decode('utf-8')
    found_date_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    exe_name = "explorer.exe"
    creator_name = "Microsoft"

    return hardware_id, exe_path, found_date_time, exe_name, creator_name


def createtable(conn):
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerabilities (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            hardware_id TEXT,
            exe_path TEXT,
            found_date_time TEXT,
            exe_name TEXT,
            creator_name TEXT
            -- Add more necessary columns here
        )
    ''')
    conn.commit()


def insert_vulnerability_info(conn, info):
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO vulnerabilities (hardware_id, exe_path, found_date_time, exe_name, creator_name)
        VALUES (?, ?, ?, ?, ?)
    ''', info)
    conn.commit()


def populate(conn, num_entries):
    for _ in range(num_entries):
        vulnerability_info = geninfo()
        insert_vulnerability_info(conn, vulnerability_info)


def fetch_vulns():
    conn = sqlite3.connect('vulnerabilities.db')
    cursor = conn.cursor()

    cursor.execute('SELECT * FROM vulnerabilities')
    data = cursor.fetchall()

    column_names = [description[0] for description in cursor.description]

    conn.close()

    result = []
    for row in data:
        entry = {}
        for i, column_name in enumerate(column_names):
            entry[column_name] = str(row[i])
        result.append(entry)

    return result


@app.route('/')
def home():
    return "Landing Page!"


@app.route('/fetch-data', methods=["GET"])
def fetch_data():
    access_key = request.args.get("key")
    if access_key:
        if access_key == "secret":
            return jsonify(fetch_vulns())
        else:
            return "Invalid Key!"
    else:
        return "Invalid Key!"


@app.route('/populate-db', methods=["POST"])
def populate_db():
    conn = sqlite3.connect('vulnerabilities.db')
    createtable(conn)
    populate(conn, 10)
    conn.close()

    return jsonify({"populated": True})


if __name__ == "__main__":
    app.run(debug=True)
